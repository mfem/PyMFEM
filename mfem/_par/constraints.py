# This file was automatically generated by SWIG (http://www.swig.org).
# Version 4.0.2
#
# Do not make changes to this file unless you know what you are doing--modify
# the SWIG interface file instead.

from sys import version_info as _swig_python_version_info
if _swig_python_version_info < (2, 7, 0):
    raise RuntimeError("Python 2.7 or later required")

# Import the low-level C/C++ module
if __package__ or "." in __name__:
    from . import _constraints
else:
    import _constraints

try:
    import builtins as __builtin__
except ImportError:
    import __builtin__

_swig_new_instance_method = _constraints.SWIG_PyInstanceMethod_New
_swig_new_static_method = _constraints.SWIG_PyStaticMethod_New

def _swig_repr(self):
    try:
        strthis = "proxy of " + self.this.__repr__()
    except __builtin__.Exception:
        strthis = ""
    return "<%s.%s; %s >" % (self.__class__.__module__, self.__class__.__name__, strthis,)


def _swig_setattr_nondynamic_instance_variable(set):
    def set_instance_attr(self, name, value):
        if name == "thisown":
            self.this.own(value)
        elif name == "this":
            set(self, name, value)
        elif hasattr(self, name) and isinstance(getattr(type(self), name), property):
            set(self, name, value)
        else:
            raise AttributeError("You cannot add instance attributes to %s" % self)
    return set_instance_attr


def _swig_setattr_nondynamic_class_variable(set):
    def set_class_attr(cls, name, value):
        if hasattr(cls, name) and not isinstance(getattr(cls, name), property):
            set(cls, name, value)
        else:
            raise AttributeError("You cannot add class attributes to %s" % cls)
    return set_class_attr


def _swig_add_metaclass(metaclass):
    """Class decorator for adding a metaclass to a SWIG wrapped class - a slimmed down version of six.add_metaclass"""
    def wrapper(cls):
        return metaclass(cls.__name__, cls.__bases__, cls.__dict__.copy())
    return wrapper


class _SwigNonDynamicMeta(type):
    """Meta class to enforce nondynamic attributes (no new attributes) for a class"""
    __setattr__ = _swig_setattr_nondynamic_class_variable(type.__setattr__)


import weakref

MFEM_VERSION = _constraints.MFEM_VERSION

MFEM_VERSION_STRING = _constraints.MFEM_VERSION_STRING

MFEM_VERSION_TYPE = _constraints.MFEM_VERSION_TYPE

MFEM_VERSION_TYPE_RELEASE = _constraints.MFEM_VERSION_TYPE_RELEASE

MFEM_VERSION_TYPE_DEVELOPMENT = _constraints.MFEM_VERSION_TYPE_DEVELOPMENT

MFEM_VERSION_MAJOR = _constraints.MFEM_VERSION_MAJOR

MFEM_VERSION_MINOR = _constraints.MFEM_VERSION_MINOR

MFEM_VERSION_PATCH = _constraints.MFEM_VERSION_PATCH

MFEM_HYPRE_VERSION = _constraints.MFEM_HYPRE_VERSION

import mfem._par.vector
import mfem._par.array
import mfem._par.mem_manager
import mfem._par.fespace
import mfem._par.coefficient
import mfem._par.globals
import mfem._par.matrix
import mfem._par.operators
import mfem._par.intrules
import mfem._par.sparsemat
import mfem._par.densemat
import mfem._par.eltrans
import mfem._par.fe
import mfem._par.geom
import mfem._par.mesh
import mfem._par.sort_pairs
import mfem._par.ncmesh
import mfem._par.vtk
import mfem._par.element
import mfem._par.table
import mfem._par.hash
import mfem._par.vertex
import mfem._par.gridfunc
import mfem._par.bilininteg
import mfem._par.fe_coll
import mfem._par.lininteg
import mfem._par.linearform
import mfem._par.nonlininteg
import mfem._par.handle
import mfem._par.hypre
import mfem._par.restriction
import mfem._par.solvers
class ConstrainedSolver(mfem._par.solvers.IterativeSolver):
    r"""Proxy of C++ mfem::ConstrainedSolver class."""

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    def __init__(self, *args):
        r"""
        __init__(ConstrainedSolver self, MPI_Comm comm, Operator A_, Operator B_) -> ConstrainedSolver
        __init__(ConstrainedSolver self, Operator A_, Operator B_) -> ConstrainedSolver
        """
        _constraints.ConstrainedSolver_swiginit(self, _constraints.new_ConstrainedSolver(*args))
    __swig_destroy__ = _constraints.delete_ConstrainedSolver

    def SetOperator(self, op):
        r"""SetOperator(ConstrainedSolver self, Operator op)"""
        return _constraints.ConstrainedSolver_SetOperator(self, op)
    SetOperator = _swig_new_instance_method(_constraints.ConstrainedSolver_SetOperator)

    def SetConstraintRHS(self, r):
        r"""SetConstraintRHS(ConstrainedSolver self, Vector r)"""
        return _constraints.ConstrainedSolver_SetConstraintRHS(self, r)
    SetConstraintRHS = _swig_new_instance_method(_constraints.ConstrainedSolver_SetConstraintRHS)

    def GetMultiplierSolution(self, _lambda):
        r"""GetMultiplierSolution(ConstrainedSolver self, Vector _lambda)"""
        return _constraints.ConstrainedSolver_GetMultiplierSolution(self, _lambda)
    GetMultiplierSolution = _swig_new_instance_method(_constraints.ConstrainedSolver_GetMultiplierSolution)

    def Mult(self, f, x):
        r"""Mult(ConstrainedSolver self, Vector f, Vector x)"""
        return _constraints.ConstrainedSolver_Mult(self, f, x)
    Mult = _swig_new_instance_method(_constraints.ConstrainedSolver_Mult)

    def LagrangeSystemMult(self, f_and_r, x_and_lambda):
        r"""LagrangeSystemMult(ConstrainedSolver self, Vector f_and_r, Vector x_and_lambda)"""
        return _constraints.ConstrainedSolver_LagrangeSystemMult(self, f_and_r, x_and_lambda)
    LagrangeSystemMult = _swig_new_instance_method(_constraints.ConstrainedSolver_LagrangeSystemMult)

# Register ConstrainedSolver in _constraints:
_constraints.ConstrainedSolver_swigregister(ConstrainedSolver)

class Eliminator(object):
    r"""Proxy of C++ mfem::Eliminator class."""

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    def __init__(self, B, lagrange_dofs, primary_tdofs, secondary_tdofs):
        r"""__init__(Eliminator self, SparseMatrix B, intArray lagrange_dofs, intArray primary_tdofs, intArray secondary_tdofs) -> Eliminator"""
        _constraints.Eliminator_swiginit(self, _constraints.new_Eliminator(B, lagrange_dofs, primary_tdofs, secondary_tdofs))

    def LagrangeDofs(self):
        r"""LagrangeDofs(Eliminator self) -> intArray"""
        return _constraints.Eliminator_LagrangeDofs(self)
    LagrangeDofs = _swig_new_instance_method(_constraints.Eliminator_LagrangeDofs)

    def PrimaryDofs(self):
        r"""PrimaryDofs(Eliminator self) -> intArray"""
        return _constraints.Eliminator_PrimaryDofs(self)
    PrimaryDofs = _swig_new_instance_method(_constraints.Eliminator_PrimaryDofs)

    def SecondaryDofs(self):
        r"""SecondaryDofs(Eliminator self) -> intArray"""
        return _constraints.Eliminator_SecondaryDofs(self)
    SecondaryDofs = _swig_new_instance_method(_constraints.Eliminator_SecondaryDofs)

    def Eliminate(self, _in, out):
        r"""Eliminate(Eliminator self, Vector _in, Vector out)"""
        return _constraints.Eliminator_Eliminate(self, _in, out)
    Eliminate = _swig_new_instance_method(_constraints.Eliminator_Eliminate)

    def EliminateTranspose(self, _in, out):
        r"""EliminateTranspose(Eliminator self, Vector _in, Vector out)"""
        return _constraints.Eliminator_EliminateTranspose(self, _in, out)
    EliminateTranspose = _swig_new_instance_method(_constraints.Eliminator_EliminateTranspose)

    def LagrangeSecondary(self, _in, out):
        r"""LagrangeSecondary(Eliminator self, Vector _in, Vector out)"""
        return _constraints.Eliminator_LagrangeSecondary(self, _in, out)
    LagrangeSecondary = _swig_new_instance_method(_constraints.Eliminator_LagrangeSecondary)

    def LagrangeSecondaryTranspose(self, _in, out):
        r"""LagrangeSecondaryTranspose(Eliminator self, Vector _in, Vector out)"""
        return _constraints.Eliminator_LagrangeSecondaryTranspose(self, _in, out)
    LagrangeSecondaryTranspose = _swig_new_instance_method(_constraints.Eliminator_LagrangeSecondaryTranspose)

    def ExplicitAssembly(self, mat):
        r"""ExplicitAssembly(Eliminator self, DenseMatrix mat)"""
        return _constraints.Eliminator_ExplicitAssembly(self, mat)
    ExplicitAssembly = _swig_new_instance_method(_constraints.Eliminator_ExplicitAssembly)
    __swig_destroy__ = _constraints.delete_Eliminator

# Register Eliminator in _constraints:
_constraints.Eliminator_swigregister(Eliminator)

class EliminationProjection(mfem._par.operators.Operator):
    r"""Proxy of C++ mfem::EliminationProjection class."""

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    def __init__(self, A, eliminators):
        r"""__init__(EliminationProjection self, Operator A, mfem::Array< mfem::Eliminator * > & eliminators) -> EliminationProjection"""
        _constraints.EliminationProjection_swiginit(self, _constraints.new_EliminationProjection(A, eliminators))

    def Mult(self, x, y):
        r"""Mult(EliminationProjection self, Vector x, Vector y)"""
        return _constraints.EliminationProjection_Mult(self, x, y)
    Mult = _swig_new_instance_method(_constraints.EliminationProjection_Mult)

    def MultTranspose(self, x, y):
        r"""MultTranspose(EliminationProjection self, Vector x, Vector y)"""
        return _constraints.EliminationProjection_MultTranspose(self, x, y)
    MultTranspose = _swig_new_instance_method(_constraints.EliminationProjection_MultTranspose)

    def AssembleExact(self):
        r"""AssembleExact(EliminationProjection self) -> SparseMatrix"""
        return _constraints.EliminationProjection_AssembleExact(self)
    AssembleExact = _swig_new_instance_method(_constraints.EliminationProjection_AssembleExact)

    def BuildGTilde(self, g, gtilde):
        r"""BuildGTilde(EliminationProjection self, Vector g, Vector gtilde)"""
        return _constraints.EliminationProjection_BuildGTilde(self, g, gtilde)
    BuildGTilde = _swig_new_instance_method(_constraints.EliminationProjection_BuildGTilde)

    def RecoverMultiplier(self, primalrhs, primalvars, lm):
        r"""RecoverMultiplier(EliminationProjection self, Vector primalrhs, Vector primalvars, Vector lm)"""
        return _constraints.EliminationProjection_RecoverMultiplier(self, primalrhs, primalvars, lm)
    RecoverMultiplier = _swig_new_instance_method(_constraints.EliminationProjection_RecoverMultiplier)
    __swig_destroy__ = _constraints.delete_EliminationProjection

# Register EliminationProjection in _constraints:
_constraints.EliminationProjection_swigregister(EliminationProjection)

class EliminationSolver(ConstrainedSolver):
    r"""Proxy of C++ mfem::EliminationSolver class."""

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined - class is abstract")
    __repr__ = _swig_repr
    __swig_destroy__ = _constraints.delete_EliminationSolver

    def Mult(self, x, y):
        r"""Mult(EliminationSolver self, Vector x, Vector y)"""
        return _constraints.EliminationSolver_Mult(self, x, y)
    Mult = _swig_new_instance_method(_constraints.EliminationSolver_Mult)

    def SetOperator(self, op):
        r"""SetOperator(EliminationSolver self, Operator op)"""
        return _constraints.EliminationSolver_SetOperator(self, op)
    SetOperator = _swig_new_instance_method(_constraints.EliminationSolver_SetOperator)

# Register EliminationSolver in _constraints:
_constraints.EliminationSolver_swigregister(EliminationSolver)

class EliminationCGSolver(EliminationSolver):
    r"""Proxy of C++ mfem::EliminationCGSolver class."""

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    def __init__(self, A, B, constraint_rowstarts, dimension_=0, reorder_=False):
        r"""__init__(EliminationCGSolver self, HypreParMatrix A, SparseMatrix B, intArray constraint_rowstarts, int dimension_=0, bool reorder_=False) -> EliminationCGSolver"""
        _constraints.EliminationCGSolver_swiginit(self, _constraints.new_EliminationCGSolver(A, B, constraint_rowstarts, dimension_, reorder_))
    __swig_destroy__ = _constraints.delete_EliminationCGSolver

# Register EliminationCGSolver in _constraints:
_constraints.EliminationCGSolver_swigregister(EliminationCGSolver)

class PenaltyConstrainedSolver(ConstrainedSolver):
    r"""Proxy of C++ mfem::PenaltyConstrainedSolver class."""

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined - class is abstract")
    __repr__ = _swig_repr
    __swig_destroy__ = _constraints.delete_PenaltyConstrainedSolver

    def Mult(self, x, y):
        r"""Mult(PenaltyConstrainedSolver self, Vector x, Vector y)"""
        return _constraints.PenaltyConstrainedSolver_Mult(self, x, y)
    Mult = _swig_new_instance_method(_constraints.PenaltyConstrainedSolver_Mult)

    def SetOperator(self, op):
        r"""SetOperator(PenaltyConstrainedSolver self, Operator op)"""
        return _constraints.PenaltyConstrainedSolver_SetOperator(self, op)
    SetOperator = _swig_new_instance_method(_constraints.PenaltyConstrainedSolver_SetOperator)

# Register PenaltyConstrainedSolver in _constraints:
_constraints.PenaltyConstrainedSolver_swigregister(PenaltyConstrainedSolver)

class PenaltyPCGSolver(PenaltyConstrainedSolver):
    r"""Proxy of C++ mfem::PenaltyPCGSolver class."""

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    def __init__(self, *args):
        r"""
        __init__(PenaltyPCGSolver self, HypreParMatrix A, SparseMatrix B, double penalty_, int dimension=0, bool reorder=False) -> PenaltyPCGSolver
        __init__(PenaltyPCGSolver self, HypreParMatrix A, HypreParMatrix B, double penalty_, int dimension=0, bool reorder=False) -> PenaltyPCGSolver
        """
        _constraints.PenaltyPCGSolver_swiginit(self, _constraints.new_PenaltyPCGSolver(*args))
    __swig_destroy__ = _constraints.delete_PenaltyPCGSolver

# Register PenaltyPCGSolver in _constraints:
_constraints.PenaltyPCGSolver_swigregister(PenaltyPCGSolver)

class SchurConstrainedSolver(ConstrainedSolver):
    r"""Proxy of C++ mfem::SchurConstrainedSolver class."""

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    def __init__(self, *args):
        r"""
        __init__(SchurConstrainedSolver self, MPI_Comm comm, Operator A_, Operator B_, Solver primal_pc_) -> SchurConstrainedSolver
        __init__(SchurConstrainedSolver self, Operator A_, Operator B_, Solver primal_pc_) -> SchurConstrainedSolver
        """
        _constraints.SchurConstrainedSolver_swiginit(self, _constraints.new_SchurConstrainedSolver(*args))
    __swig_destroy__ = _constraints.delete_SchurConstrainedSolver

    def LagrangeSystemMult(self, x, y):
        r"""LagrangeSystemMult(SchurConstrainedSolver self, Vector x, Vector y)"""
        return _constraints.SchurConstrainedSolver_LagrangeSystemMult(self, x, y)
    LagrangeSystemMult = _swig_new_instance_method(_constraints.SchurConstrainedSolver_LagrangeSystemMult)

# Register SchurConstrainedSolver in _constraints:
_constraints.SchurConstrainedSolver_swigregister(SchurConstrainedSolver)

class SchurConstrainedHypreSolver(SchurConstrainedSolver):
    r"""Proxy of C++ mfem::SchurConstrainedHypreSolver class."""

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    def __init__(self, comm, hA_, hB_, dimension=0, reorder=False):
        r"""__init__(SchurConstrainedHypreSolver self, MPI_Comm comm, HypreParMatrix hA_, HypreParMatrix hB_, int dimension=0, bool reorder=False) -> SchurConstrainedHypreSolver"""
        _constraints.SchurConstrainedHypreSolver_swiginit(self, _constraints.new_SchurConstrainedHypreSolver(comm, hA_, hB_, dimension, reorder))
    __swig_destroy__ = _constraints.delete_SchurConstrainedHypreSolver

# Register SchurConstrainedHypreSolver in _constraints:
_constraints.SchurConstrainedHypreSolver_swigregister(SchurConstrainedHypreSolver)


def BuildNormalConstraints(fespace, constrained_att, constraint_rowstarts, parallel=False):
    r"""BuildNormalConstraints(FiniteElementSpace fespace, intArray constrained_att, intArray constraint_rowstarts, bool parallel=False) -> SparseMatrix"""
    return _constraints.BuildNormalConstraints(fespace, constrained_att, constraint_rowstarts, parallel)
BuildNormalConstraints = _constraints.BuildNormalConstraints

def ParBuildNormalConstraints(fespace, constrained_att, constraint_rowstarts):
    r"""ParBuildNormalConstraints(mfem::ParFiniteElementSpace & fespace, intArray constrained_att, intArray constraint_rowstarts) -> SparseMatrix"""
    return _constraints.ParBuildNormalConstraints(fespace, constrained_att, constraint_rowstarts)
ParBuildNormalConstraints = _constraints.ParBuildNormalConstraints


