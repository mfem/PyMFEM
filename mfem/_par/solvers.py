# This file was automatically generated by SWIG (http://www.swig.org).
# Version 4.0.2
#
# Do not make changes to this file unless you know what you are doing--modify
# the SWIG interface file instead.

from sys import version_info as _swig_python_version_info
if _swig_python_version_info < (2, 7, 0):
    raise RuntimeError("Python 2.7 or later required")

# Import the low-level C/C++ module
if __package__ or "." in __name__:
    from . import _solvers
else:
    import _solvers

try:
    import builtins as __builtin__
except ImportError:
    import __builtin__

_swig_new_instance_method = _solvers.SWIG_PyInstanceMethod_New
_swig_new_static_method = _solvers.SWIG_PyStaticMethod_New

def _swig_repr(self):
    try:
        strthis = "proxy of " + self.this.__repr__()
    except __builtin__.Exception:
        strthis = ""
    return "<%s.%s; %s >" % (self.__class__.__module__, self.__class__.__name__, strthis,)


def _swig_setattr_nondynamic_instance_variable(set):
    def set_instance_attr(self, name, value):
        if name == "thisown":
            self.this.own(value)
        elif name == "this":
            set(self, name, value)
        elif hasattr(self, name) and isinstance(getattr(type(self), name), property):
            set(self, name, value)
        else:
            raise AttributeError("You cannot add instance attributes to %s" % self)
    return set_instance_attr


def _swig_setattr_nondynamic_class_variable(set):
    def set_class_attr(cls, name, value):
        if hasattr(cls, name) and not isinstance(getattr(cls, name), property):
            set(cls, name, value)
        else:
            raise AttributeError("You cannot add class attributes to %s" % cls)
    return set_class_attr


def _swig_add_metaclass(metaclass):
    """Class decorator for adding a metaclass to a SWIG wrapped class - a slimmed down version of six.add_metaclass"""
    def wrapper(cls):
        return metaclass(cls.__name__, cls.__bases__, cls.__dict__.copy())
    return wrapper


class _SwigNonDynamicMeta(type):
    """Meta class to enforce nondynamic attributes (no new attributes) for a class"""
    __setattr__ = _swig_setattr_nondynamic_class_variable(type.__setattr__)


import weakref

MFEM_VERSION = _solvers.MFEM_VERSION
MFEM_VERSION_STRING = _solvers.MFEM_VERSION_STRING
MFEM_VERSION_TYPE = _solvers.MFEM_VERSION_TYPE
MFEM_VERSION_TYPE_RELEASE = _solvers.MFEM_VERSION_TYPE_RELEASE
MFEM_VERSION_TYPE_DEVELOPMENT = _solvers.MFEM_VERSION_TYPE_DEVELOPMENT
MFEM_VERSION_MAJOR = _solvers.MFEM_VERSION_MAJOR
MFEM_VERSION_MINOR = _solvers.MFEM_VERSION_MINOR
MFEM_VERSION_PATCH = _solvers.MFEM_VERSION_PATCH
MFEM_HYPRE_VERSION = _solvers.MFEM_HYPRE_VERSION
import mfem._par.vector
import mfem._par.array
import mfem._par.mem_manager
import mfem._par.operators
import mfem._par.matrix
import mfem._par.sparsemat
import mfem._par.densemat
class IterativeSolverMonitor(object):
    r"""Proxy of C++ mfem::IterativeSolverMonitor class."""

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    def __init__(self):
        r"""__init__(IterativeSolverMonitor self) -> IterativeSolverMonitor"""
        if self.__class__ == IterativeSolverMonitor:
            _self = None
        else:
            _self = self
        _solvers.IterativeSolverMonitor_swiginit(self, _solvers.new_IterativeSolverMonitor(_self, ))
    __swig_destroy__ = _solvers.delete_IterativeSolverMonitor

    def MonitorResidual(self, it, norm, r, final):
        r"""MonitorResidual(IterativeSolverMonitor self, int it, double norm, Vector r, bool final)"""
        return _solvers.IterativeSolverMonitor_MonitorResidual(self, it, norm, r, final)
    MonitorResidual = _swig_new_instance_method(_solvers.IterativeSolverMonitor_MonitorResidual)

    def MonitorSolution(self, it, norm, x, final):
        r"""MonitorSolution(IterativeSolverMonitor self, int it, double norm, Vector x, bool final)"""
        return _solvers.IterativeSolverMonitor_MonitorSolution(self, it, norm, x, final)
    MonitorSolution = _swig_new_instance_method(_solvers.IterativeSolverMonitor_MonitorSolution)
    def __disown__(self):
        self.this.disown()
        _solvers.disown_IterativeSolverMonitor(self)
        return weakref.proxy(self)

# Register IterativeSolverMonitor in _solvers:
_solvers.IterativeSolverMonitor_swigregister(IterativeSolverMonitor)

class IterativeSolver(mfem._par.operators.Solver):
    r"""Proxy of C++ mfem::IterativeSolver class."""

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined - class is abstract")
    __repr__ = _swig_repr

    def SetRelTol(self, rtol):
        r"""SetRelTol(IterativeSolver self, double rtol)"""
        return _solvers.IterativeSolver_SetRelTol(self, rtol)
    SetRelTol = _swig_new_instance_method(_solvers.IterativeSolver_SetRelTol)

    def SetAbsTol(self, atol):
        r"""SetAbsTol(IterativeSolver self, double atol)"""
        return _solvers.IterativeSolver_SetAbsTol(self, atol)
    SetAbsTol = _swig_new_instance_method(_solvers.IterativeSolver_SetAbsTol)

    def SetMaxIter(self, max_it):
        r"""SetMaxIter(IterativeSolver self, int max_it)"""
        return _solvers.IterativeSolver_SetMaxIter(self, max_it)
    SetMaxIter = _swig_new_instance_method(_solvers.IterativeSolver_SetMaxIter)

    def SetPrintLevel(self, print_lvl):
        r"""SetPrintLevel(IterativeSolver self, int print_lvl)"""
        return _solvers.IterativeSolver_SetPrintLevel(self, print_lvl)
    SetPrintLevel = _swig_new_instance_method(_solvers.IterativeSolver_SetPrintLevel)

    def GetNumIterations(self):
        r"""GetNumIterations(IterativeSolver self) -> int"""
        return _solvers.IterativeSolver_GetNumIterations(self)
    GetNumIterations = _swig_new_instance_method(_solvers.IterativeSolver_GetNumIterations)

    def GetConverged(self):
        r"""GetConverged(IterativeSolver self) -> int"""
        return _solvers.IterativeSolver_GetConverged(self)
    GetConverged = _swig_new_instance_method(_solvers.IterativeSolver_GetConverged)

    def GetFinalNorm(self):
        r"""GetFinalNorm(IterativeSolver self) -> double"""
        return _solvers.IterativeSolver_GetFinalNorm(self)
    GetFinalNorm = _swig_new_instance_method(_solvers.IterativeSolver_GetFinalNorm)

    def SetPreconditioner(self, pr):
        r"""SetPreconditioner(IterativeSolver self, Solver pr)"""
        return _solvers.IterativeSolver_SetPreconditioner(self, pr)
    SetPreconditioner = _swig_new_instance_method(_solvers.IterativeSolver_SetPreconditioner)

    def SetOperator(self, op):
        r"""SetOperator(IterativeSolver self, Operator op)"""
        return _solvers.IterativeSolver_SetOperator(self, op)
    SetOperator = _swig_new_instance_method(_solvers.IterativeSolver_SetOperator)

    def SetMonitor(self, m):
        r"""SetMonitor(IterativeSolver self, IterativeSolverMonitor m)"""
        return _solvers.IterativeSolver_SetMonitor(self, m)
    SetMonitor = _swig_new_instance_method(_solvers.IterativeSolver_SetMonitor)

    def GetComm(self):
        r"""GetComm(IterativeSolver self) -> MPI_Comm"""
        return _solvers.IterativeSolver_GetComm(self)
    GetComm = _swig_new_instance_method(_solvers.IterativeSolver_GetComm)
    __swig_destroy__ = _solvers.delete_IterativeSolver

# Register IterativeSolver in _solvers:
_solvers.IterativeSolver_swigregister(IterativeSolver)

class OperatorJacobiSmoother(mfem._par.operators.Solver):
    r"""Proxy of C++ mfem::OperatorJacobiSmoother class."""

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    def __init__(self, *args):
        r"""
        __init__(OperatorJacobiSmoother self, double const damping=1.0) -> OperatorJacobiSmoother
        __init__(OperatorJacobiSmoother self, mfem::BilinearForm const & a, intArray ess_tdof_list, double const damping=1.0) -> OperatorJacobiSmoother
        __init__(OperatorJacobiSmoother self, Vector d, intArray ess_tdof_list, double const damping=1.0) -> OperatorJacobiSmoother
        """
        _solvers.OperatorJacobiSmoother_swiginit(self, _solvers.new_OperatorJacobiSmoother(*args))
    __swig_destroy__ = _solvers.delete_OperatorJacobiSmoother

    def Mult(self, x, y):
        r"""Mult(OperatorJacobiSmoother self, Vector x, Vector y)"""
        return _solvers.OperatorJacobiSmoother_Mult(self, x, y)
    Mult = _swig_new_instance_method(_solvers.OperatorJacobiSmoother_Mult)

    def MultTranspose(self, x, y):
        r"""MultTranspose(OperatorJacobiSmoother self, Vector x, Vector y)"""
        return _solvers.OperatorJacobiSmoother_MultTranspose(self, x, y)
    MultTranspose = _swig_new_instance_method(_solvers.OperatorJacobiSmoother_MultTranspose)

    def SetOperator(self, op):
        r"""SetOperator(OperatorJacobiSmoother self, Operator op)"""
        return _solvers.OperatorJacobiSmoother_SetOperator(self, op)
    SetOperator = _swig_new_instance_method(_solvers.OperatorJacobiSmoother_SetOperator)

    def Setup(self, diag):
        r"""Setup(OperatorJacobiSmoother self, Vector diag)"""
        return _solvers.OperatorJacobiSmoother_Setup(self, diag)
    Setup = _swig_new_instance_method(_solvers.OperatorJacobiSmoother_Setup)

# Register OperatorJacobiSmoother in _solvers:
_solvers.OperatorJacobiSmoother_swigregister(OperatorJacobiSmoother)

class OperatorChebyshevSmoother(mfem._par.operators.Solver):
    r"""Proxy of C++ mfem::OperatorChebyshevSmoother class."""

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    def __init__(self, *args):
        r"""
        __init__(OperatorChebyshevSmoother self, Operator oper_, Vector d, intArray ess_tdof_list, int order, double max_eig_estimate) -> OperatorChebyshevSmoother
        __init__(OperatorChebyshevSmoother self, Operator oper_, Vector d, intArray ess_tdof_list, int order, MPI_Comm comm=MPI_COMM_NULL, int power_iterations=10, double power_tolerance=1e-8) -> OperatorChebyshevSmoother
        """
        _solvers.OperatorChebyshevSmoother_swiginit(self, _solvers.new_OperatorChebyshevSmoother(*args))
    __swig_destroy__ = _solvers.delete_OperatorChebyshevSmoother

    def Mult(self, x, y):
        r"""Mult(OperatorChebyshevSmoother self, Vector x, Vector y)"""
        return _solvers.OperatorChebyshevSmoother_Mult(self, x, y)
    Mult = _swig_new_instance_method(_solvers.OperatorChebyshevSmoother_Mult)

    def MultTranspose(self, x, y):
        r"""MultTranspose(OperatorChebyshevSmoother self, Vector x, Vector y)"""
        return _solvers.OperatorChebyshevSmoother_MultTranspose(self, x, y)
    MultTranspose = _swig_new_instance_method(_solvers.OperatorChebyshevSmoother_MultTranspose)

    def SetOperator(self, op_):
        r"""SetOperator(OperatorChebyshevSmoother self, Operator op_)"""
        return _solvers.OperatorChebyshevSmoother_SetOperator(self, op_)
    SetOperator = _swig_new_instance_method(_solvers.OperatorChebyshevSmoother_SetOperator)

    def Setup(self):
        r"""Setup(OperatorChebyshevSmoother self)"""
        return _solvers.OperatorChebyshevSmoother_Setup(self)
    Setup = _swig_new_instance_method(_solvers.OperatorChebyshevSmoother_Setup)

# Register OperatorChebyshevSmoother in _solvers:
_solvers.OperatorChebyshevSmoother_swigregister(OperatorChebyshevSmoother)

class SLISolver(IterativeSolver):
    r"""Proxy of C++ mfem::SLISolver class."""

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    def __init__(self, *args):
        r"""
        __init__(SLISolver self) -> SLISolver
        __init__(SLISolver self, MPI_Comm comm_) -> SLISolver
        """
        _solvers.SLISolver_swiginit(self, _solvers.new_SLISolver(*args))

    def SetOperator(self, op):
        r"""SetOperator(SLISolver self, Operator op)"""
        return _solvers.SLISolver_SetOperator(self, op)
    SetOperator = _swig_new_instance_method(_solvers.SLISolver_SetOperator)

    def Mult(self, b, x):
        r"""Mult(SLISolver self, Vector b, Vector x)"""
        return _solvers.SLISolver_Mult(self, b, x)
    Mult = _swig_new_instance_method(_solvers.SLISolver_Mult)
    __swig_destroy__ = _solvers.delete_SLISolver

# Register SLISolver in _solvers:
_solvers.SLISolver_swigregister(SLISolver)


def SLI(*args):
    r"""
    SLI(Operator A, Vector b, Vector x, int print_iter=0, int max_num_iter=1000, double RTOLERANCE=1e-12, double ATOLERANCE=1e-24)
    SLI(Operator A, Solver B, Vector b, Vector x, int print_iter=0, int max_num_iter=1000, double RTOLERANCE=1e-12, double ATOLERANCE=1e-24)
    """
    return _solvers.SLI(*args)
SLI = _solvers.SLI
class CGSolver(IterativeSolver):
    r"""Proxy of C++ mfem::CGSolver class."""

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    def __init__(self, *args):
        r"""
        __init__(CGSolver self) -> CGSolver
        __init__(CGSolver self, MPI_Comm comm_) -> CGSolver
        """
        _solvers.CGSolver_swiginit(self, _solvers.new_CGSolver(*args))

    def SetOperator(self, op):
        r"""SetOperator(CGSolver self, Operator op)"""
        return _solvers.CGSolver_SetOperator(self, op)
    SetOperator = _swig_new_instance_method(_solvers.CGSolver_SetOperator)

    def Mult(self, b, x):
        r"""Mult(CGSolver self, Vector b, Vector x)"""
        return _solvers.CGSolver_Mult(self, b, x)
    Mult = _swig_new_instance_method(_solvers.CGSolver_Mult)
    __swig_destroy__ = _solvers.delete_CGSolver

# Register CGSolver in _solvers:
_solvers.CGSolver_swigregister(CGSolver)


def CG(A, b, x, print_iter=0, max_num_iter=1000, RTOLERANCE=1e-12, ATOLERANCE=1e-24):
    r"""CG(Operator A, Vector b, Vector x, int print_iter=0, int max_num_iter=1000, double RTOLERANCE=1e-12, double ATOLERANCE=1e-24)"""
    return _solvers.CG(A, b, x, print_iter, max_num_iter, RTOLERANCE, ATOLERANCE)
CG = _solvers.CG

def PCG(A, B, b, x, print_iter=0, max_num_iter=1000, RTOLERANCE=1e-12, ATOLERANCE=1e-24):
    r"""PCG(Operator A, Solver B, Vector b, Vector x, int print_iter=0, int max_num_iter=1000, double RTOLERANCE=1e-12, double ATOLERANCE=1e-24)"""
    return _solvers.PCG(A, B, b, x, print_iter, max_num_iter, RTOLERANCE, ATOLERANCE)
PCG = _solvers.PCG
class GMRESSolver(IterativeSolver):
    r"""Proxy of C++ mfem::GMRESSolver class."""

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    def __init__(self, *args):
        r"""
        __init__(GMRESSolver self) -> GMRESSolver
        __init__(GMRESSolver self, MPI_Comm comm_) -> GMRESSolver
        """
        _solvers.GMRESSolver_swiginit(self, _solvers.new_GMRESSolver(*args))

    def SetKDim(self, dim):
        r"""SetKDim(GMRESSolver self, int dim)"""
        return _solvers.GMRESSolver_SetKDim(self, dim)
    SetKDim = _swig_new_instance_method(_solvers.GMRESSolver_SetKDim)

    def Mult(self, b, x):
        r"""Mult(GMRESSolver self, Vector b, Vector x)"""
        return _solvers.GMRESSolver_Mult(self, b, x)
    Mult = _swig_new_instance_method(_solvers.GMRESSolver_Mult)
    __swig_destroy__ = _solvers.delete_GMRESSolver

# Register GMRESSolver in _solvers:
_solvers.GMRESSolver_swigregister(GMRESSolver)

class FGMRESSolver(IterativeSolver):
    r"""Proxy of C++ mfem::FGMRESSolver class."""

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    def __init__(self, *args):
        r"""
        __init__(FGMRESSolver self) -> FGMRESSolver
        __init__(FGMRESSolver self, MPI_Comm comm_) -> FGMRESSolver
        """
        _solvers.FGMRESSolver_swiginit(self, _solvers.new_FGMRESSolver(*args))

    def SetKDim(self, dim):
        r"""SetKDim(FGMRESSolver self, int dim)"""
        return _solvers.FGMRESSolver_SetKDim(self, dim)
    SetKDim = _swig_new_instance_method(_solvers.FGMRESSolver_SetKDim)

    def Mult(self, b, x):
        r"""Mult(FGMRESSolver self, Vector b, Vector x)"""
        return _solvers.FGMRESSolver_Mult(self, b, x)
    Mult = _swig_new_instance_method(_solvers.FGMRESSolver_Mult)
    __swig_destroy__ = _solvers.delete_FGMRESSolver

# Register FGMRESSolver in _solvers:
_solvers.FGMRESSolver_swigregister(FGMRESSolver)


def GMRES(*args):
    r"""
    GMRES(Operator A, Vector x, Vector b, Solver M, int & max_iter, int m, double & tol, double atol, int printit) -> int
    GMRES(Operator A, Solver B, Vector b, Vector x, int print_iter=0, int max_num_iter=1000, int m=50, double rtol=1e-12, double atol=1e-24)
    """
    return _solvers.GMRES(*args)
GMRES = _solvers.GMRES
class BiCGSTABSolver(IterativeSolver):
    r"""Proxy of C++ mfem::BiCGSTABSolver class."""

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    def __init__(self, *args):
        r"""
        __init__(BiCGSTABSolver self) -> BiCGSTABSolver
        __init__(BiCGSTABSolver self, MPI_Comm comm_) -> BiCGSTABSolver
        """
        _solvers.BiCGSTABSolver_swiginit(self, _solvers.new_BiCGSTABSolver(*args))

    def SetOperator(self, op):
        r"""SetOperator(BiCGSTABSolver self, Operator op)"""
        return _solvers.BiCGSTABSolver_SetOperator(self, op)
    SetOperator = _swig_new_instance_method(_solvers.BiCGSTABSolver_SetOperator)

    def Mult(self, b, x):
        r"""Mult(BiCGSTABSolver self, Vector b, Vector x)"""
        return _solvers.BiCGSTABSolver_Mult(self, b, x)
    Mult = _swig_new_instance_method(_solvers.BiCGSTABSolver_Mult)
    __swig_destroy__ = _solvers.delete_BiCGSTABSolver

# Register BiCGSTABSolver in _solvers:
_solvers.BiCGSTABSolver_swigregister(BiCGSTABSolver)


def BiCGSTAB(*args):
    r"""
    BiCGSTAB(Operator A, Vector x, Vector b, Solver M, int & max_iter, double & tol, double atol, int printit) -> int
    BiCGSTAB(Operator A, Solver B, Vector b, Vector x, int print_iter=0, int max_num_iter=1000, double rtol=1e-12, double atol=1e-24)
    """
    return _solvers.BiCGSTAB(*args)
BiCGSTAB = _solvers.BiCGSTAB
class MINRESSolver(IterativeSolver):
    r"""Proxy of C++ mfem::MINRESSolver class."""

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    def __init__(self, *args):
        r"""
        __init__(MINRESSolver self) -> MINRESSolver
        __init__(MINRESSolver self, MPI_Comm comm_) -> MINRESSolver
        """
        _solvers.MINRESSolver_swiginit(self, _solvers.new_MINRESSolver(*args))

    def SetPreconditioner(self, pr):
        r"""SetPreconditioner(MINRESSolver self, Solver pr)"""
        return _solvers.MINRESSolver_SetPreconditioner(self, pr)
    SetPreconditioner = _swig_new_instance_method(_solvers.MINRESSolver_SetPreconditioner)

    def SetOperator(self, op):
        r"""SetOperator(MINRESSolver self, Operator op)"""
        return _solvers.MINRESSolver_SetOperator(self, op)
    SetOperator = _swig_new_instance_method(_solvers.MINRESSolver_SetOperator)

    def Mult(self, b, x):
        r"""Mult(MINRESSolver self, Vector b, Vector x)"""
        return _solvers.MINRESSolver_Mult(self, b, x)
    Mult = _swig_new_instance_method(_solvers.MINRESSolver_Mult)
    __swig_destroy__ = _solvers.delete_MINRESSolver

# Register MINRESSolver in _solvers:
_solvers.MINRESSolver_swigregister(MINRESSolver)


def MINRES(*args):
    r"""
    MINRES(Operator A, Vector b, Vector x, int print_it=0, int max_it=1000, double rtol=1e-12, double atol=1e-24)
    MINRES(Operator A, Solver B, Vector b, Vector x, int print_it=0, int max_it=1000, double rtol=1e-12, double atol=1e-24)
    """
    return _solvers.MINRES(*args)
MINRES = _solvers.MINRES
class NewtonSolver(IterativeSolver):
    r"""Proxy of C++ mfem::NewtonSolver class."""

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    def __init__(self, *args):
        r"""
        __init__(NewtonSolver self) -> NewtonSolver
        __init__(NewtonSolver self, MPI_Comm comm_) -> NewtonSolver
        """
        _solvers.NewtonSolver_swiginit(self, _solvers.new_NewtonSolver(*args))

    def SetOperator(self, op):
        r"""SetOperator(NewtonSolver self, Operator op)"""
        return _solvers.NewtonSolver_SetOperator(self, op)
    SetOperator = _swig_new_instance_method(_solvers.NewtonSolver_SetOperator)

    def SetSolver(self, solver):
        r"""SetSolver(NewtonSolver self, Solver solver)"""
        return _solvers.NewtonSolver_SetSolver(self, solver)
    SetSolver = _swig_new_instance_method(_solvers.NewtonSolver_SetSolver)

    def Mult(self, b, x):
        r"""Mult(NewtonSolver self, Vector b, Vector x)"""
        return _solvers.NewtonSolver_Mult(self, b, x)
    Mult = _swig_new_instance_method(_solvers.NewtonSolver_Mult)

    def ComputeScalingFactor(self, x, b):
        r"""ComputeScalingFactor(NewtonSolver self, Vector x, Vector b) -> double"""
        return _solvers.NewtonSolver_ComputeScalingFactor(self, x, b)
    ComputeScalingFactor = _swig_new_instance_method(_solvers.NewtonSolver_ComputeScalingFactor)

    def ProcessNewState(self, x):
        r"""ProcessNewState(NewtonSolver self, Vector x)"""
        return _solvers.NewtonSolver_ProcessNewState(self, x)
    ProcessNewState = _swig_new_instance_method(_solvers.NewtonSolver_ProcessNewState)

    def SetAdaptiveLinRtol(self, *args, **kwargs):
        r"""SetAdaptiveLinRtol(NewtonSolver self, int const type=2, double const rtol0=0.5, double const rtol_max=0.9, double const alpha=0.5*(1.0+sqrt(5.0)), double const gamma=1.0)"""
        return _solvers.NewtonSolver_SetAdaptiveLinRtol(self, *args, **kwargs)
    SetAdaptiveLinRtol = _swig_new_instance_method(_solvers.NewtonSolver_SetAdaptiveLinRtol)
    __swig_destroy__ = _solvers.delete_NewtonSolver

# Register NewtonSolver in _solvers:
_solvers.NewtonSolver_swigregister(NewtonSolver)

class LBFGSSolver(NewtonSolver):
    r"""Proxy of C++ mfem::LBFGSSolver class."""

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    def __init__(self, *args):
        r"""
        __init__(LBFGSSolver self) -> LBFGSSolver
        __init__(LBFGSSolver self, MPI_Comm comm_) -> LBFGSSolver
        """
        _solvers.LBFGSSolver_swiginit(self, _solvers.new_LBFGSSolver(*args))

    def SetHistorySize(self, dim):
        r"""SetHistorySize(LBFGSSolver self, int dim)"""
        return _solvers.LBFGSSolver_SetHistorySize(self, dim)
    SetHistorySize = _swig_new_instance_method(_solvers.LBFGSSolver_SetHistorySize)

    def Mult(self, b, x):
        r"""Mult(LBFGSSolver self, Vector b, Vector x)"""
        return _solvers.LBFGSSolver_Mult(self, b, x)
    Mult = _swig_new_instance_method(_solvers.LBFGSSolver_Mult)

    def SetPreconditioner(self, pr):
        r"""SetPreconditioner(LBFGSSolver self, Solver pr)"""
        return _solvers.LBFGSSolver_SetPreconditioner(self, pr)
    SetPreconditioner = _swig_new_instance_method(_solvers.LBFGSSolver_SetPreconditioner)

    def SetSolver(self, solver):
        r"""SetSolver(LBFGSSolver self, Solver solver)"""
        return _solvers.LBFGSSolver_SetSolver(self, solver)
    SetSolver = _swig_new_instance_method(_solvers.LBFGSSolver_SetSolver)
    __swig_destroy__ = _solvers.delete_LBFGSSolver

# Register LBFGSSolver in _solvers:
_solvers.LBFGSSolver_swigregister(LBFGSSolver)


def aGMRES(A, x, b, M, max_iter, m_max, m_min, m_step, cf, tol, atol, printit):
    r"""aGMRES(Operator A, Vector x, Vector b, Operator M, int & max_iter, int m_max, int m_min, int m_step, double cf, double & tol, double & atol, int printit) -> int"""
    return _solvers.aGMRES(A, x, b, M, max_iter, m_max, m_min, m_step, cf, tol, atol, printit)
aGMRES = _solvers.aGMRES
class OptimizationProblem(object):
    r"""Proxy of C++ mfem::OptimizationProblem class."""

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined - class is abstract")
    __repr__ = _swig_repr
    input_size = property(_solvers.OptimizationProblem_input_size_get, doc=r"""input_size : q(const).int""")

    def CalcObjective(self, x):
        r"""CalcObjective(OptimizationProblem self, Vector x) -> double"""
        return _solvers.OptimizationProblem_CalcObjective(self, x)
    CalcObjective = _swig_new_instance_method(_solvers.OptimizationProblem_CalcObjective)

    def CalcObjectiveGrad(self, x, grad):
        r"""CalcObjectiveGrad(OptimizationProblem self, Vector x, Vector grad)"""
        return _solvers.OptimizationProblem_CalcObjectiveGrad(self, x, grad)
    CalcObjectiveGrad = _swig_new_instance_method(_solvers.OptimizationProblem_CalcObjectiveGrad)

    def SetEqualityConstraint(self, c):
        r"""SetEqualityConstraint(OptimizationProblem self, Vector c)"""
        return _solvers.OptimizationProblem_SetEqualityConstraint(self, c)
    SetEqualityConstraint = _swig_new_instance_method(_solvers.OptimizationProblem_SetEqualityConstraint)

    def SetInequalityConstraint(self, dl, dh):
        r"""SetInequalityConstraint(OptimizationProblem self, Vector dl, Vector dh)"""
        return _solvers.OptimizationProblem_SetInequalityConstraint(self, dl, dh)
    SetInequalityConstraint = _swig_new_instance_method(_solvers.OptimizationProblem_SetInequalityConstraint)

    def SetSolutionBounds(self, xl, xh):
        r"""SetSolutionBounds(OptimizationProblem self, Vector xl, Vector xh)"""
        return _solvers.OptimizationProblem_SetSolutionBounds(self, xl, xh)
    SetSolutionBounds = _swig_new_instance_method(_solvers.OptimizationProblem_SetSolutionBounds)

    def GetC(self):
        r"""GetC(OptimizationProblem self) -> Operator"""
        return _solvers.OptimizationProblem_GetC(self)
    GetC = _swig_new_instance_method(_solvers.OptimizationProblem_GetC)

    def GetD(self):
        r"""GetD(OptimizationProblem self) -> Operator"""
        return _solvers.OptimizationProblem_GetD(self)
    GetD = _swig_new_instance_method(_solvers.OptimizationProblem_GetD)

    def GetEqualityVec(self):
        r"""GetEqualityVec(OptimizationProblem self) -> Vector"""
        return _solvers.OptimizationProblem_GetEqualityVec(self)
    GetEqualityVec = _swig_new_instance_method(_solvers.OptimizationProblem_GetEqualityVec)

    def GetInequalityVec_Lo(self):
        r"""GetInequalityVec_Lo(OptimizationProblem self) -> Vector"""
        return _solvers.OptimizationProblem_GetInequalityVec_Lo(self)
    GetInequalityVec_Lo = _swig_new_instance_method(_solvers.OptimizationProblem_GetInequalityVec_Lo)

    def GetInequalityVec_Hi(self):
        r"""GetInequalityVec_Hi(OptimizationProblem self) -> Vector"""
        return _solvers.OptimizationProblem_GetInequalityVec_Hi(self)
    GetInequalityVec_Hi = _swig_new_instance_method(_solvers.OptimizationProblem_GetInequalityVec_Hi)

    def GetBoundsVec_Lo(self):
        r"""GetBoundsVec_Lo(OptimizationProblem self) -> Vector"""
        return _solvers.OptimizationProblem_GetBoundsVec_Lo(self)
    GetBoundsVec_Lo = _swig_new_instance_method(_solvers.OptimizationProblem_GetBoundsVec_Lo)

    def GetBoundsVec_Hi(self):
        r"""GetBoundsVec_Hi(OptimizationProblem self) -> Vector"""
        return _solvers.OptimizationProblem_GetBoundsVec_Hi(self)
    GetBoundsVec_Hi = _swig_new_instance_method(_solvers.OptimizationProblem_GetBoundsVec_Hi)

    def GetNumConstraints(self):
        r"""GetNumConstraints(OptimizationProblem self) -> int"""
        return _solvers.OptimizationProblem_GetNumConstraints(self)
    GetNumConstraints = _swig_new_instance_method(_solvers.OptimizationProblem_GetNumConstraints)
    __swig_destroy__ = _solvers.delete_OptimizationProblem

# Register OptimizationProblem in _solvers:
_solvers.OptimizationProblem_swigregister(OptimizationProblem)

class OptimizationSolver(IterativeSolver):
    r"""Proxy of C++ mfem::OptimizationSolver class."""

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined - class is abstract")
    __repr__ = _swig_repr
    __swig_destroy__ = _solvers.delete_OptimizationSolver

    def SetOptimizationProblem(self, prob):
        r"""SetOptimizationProblem(OptimizationSolver self, OptimizationProblem prob)"""
        return _solvers.OptimizationSolver_SetOptimizationProblem(self, prob)
    SetOptimizationProblem = _swig_new_instance_method(_solvers.OptimizationSolver_SetOptimizationProblem)

    def Mult(self, xt, x):
        r"""Mult(OptimizationSolver self, Vector xt, Vector x)"""
        return _solvers.OptimizationSolver_Mult(self, xt, x)
    Mult = _swig_new_instance_method(_solvers.OptimizationSolver_Mult)

    def SetPreconditioner(self, pr):
        r"""SetPreconditioner(OptimizationSolver self, Solver pr)"""
        return _solvers.OptimizationSolver_SetPreconditioner(self, pr)
    SetPreconditioner = _swig_new_instance_method(_solvers.OptimizationSolver_SetPreconditioner)

    def SetOperator(self, op):
        r"""SetOperator(OptimizationSolver self, Operator op)"""
        return _solvers.OptimizationSolver_SetOperator(self, op)
    SetOperator = _swig_new_instance_method(_solvers.OptimizationSolver_SetOperator)

# Register OptimizationSolver in _solvers:
_solvers.OptimizationSolver_swigregister(OptimizationSolver)

class SLBQPOptimizer(OptimizationSolver):
    r"""Proxy of C++ mfem::SLBQPOptimizer class."""

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    def __init__(self, *args):
        r"""
        __init__(SLBQPOptimizer self) -> SLBQPOptimizer
        __init__(SLBQPOptimizer self, MPI_Comm comm_) -> SLBQPOptimizer
        """
        _solvers.SLBQPOptimizer_swiginit(self, _solvers.new_SLBQPOptimizer(*args))

    def SetOptimizationProblem(self, prob):
        r"""SetOptimizationProblem(SLBQPOptimizer self, OptimizationProblem prob)"""
        return _solvers.SLBQPOptimizer_SetOptimizationProblem(self, prob)
    SetOptimizationProblem = _swig_new_instance_method(_solvers.SLBQPOptimizer_SetOptimizationProblem)

    def SetBounds(self, lo_, hi_):
        r"""SetBounds(SLBQPOptimizer self, Vector lo_, Vector hi_)"""
        return _solvers.SLBQPOptimizer_SetBounds(self, lo_, hi_)
    SetBounds = _swig_new_instance_method(_solvers.SLBQPOptimizer_SetBounds)

    def SetLinearConstraint(self, w_, a_):
        r"""SetLinearConstraint(SLBQPOptimizer self, Vector w_, double a_)"""
        return _solvers.SLBQPOptimizer_SetLinearConstraint(self, w_, a_)
    SetLinearConstraint = _swig_new_instance_method(_solvers.SLBQPOptimizer_SetLinearConstraint)

    def Mult(self, xt, x):
        r"""Mult(SLBQPOptimizer self, Vector xt, Vector x)"""
        return _solvers.SLBQPOptimizer_Mult(self, xt, x)
    Mult = _swig_new_instance_method(_solvers.SLBQPOptimizer_Mult)
    __swig_destroy__ = _solvers.delete_SLBQPOptimizer

# Register SLBQPOptimizer in _solvers:
_solvers.SLBQPOptimizer_swigregister(SLBQPOptimizer)

class BlockILU(mfem._par.operators.Solver):
    r"""Proxy of C++ mfem::BlockILU class."""

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr
    Reordering_MINIMUM_DISCARDED_FILL = _solvers.BlockILU_Reordering_MINIMUM_DISCARDED_FILL
    
    Reordering_NONE = _solvers.BlockILU_Reordering_NONE
    

    def __init__(self, *args):
        r"""
        __init__(BlockILU self, int block_size_, mfem::BlockILU::Reordering reordering_=MINIMUM_DISCARDED_FILL, int k_fill_=0) -> BlockILU
        __init__(BlockILU self, Operator op, int block_size_=1, mfem::BlockILU::Reordering reordering_=MINIMUM_DISCARDED_FILL, int k_fill_=0) -> BlockILU
        """
        _solvers.BlockILU_swiginit(self, _solvers.new_BlockILU(*args))

    def SetOperator(self, op):
        r"""SetOperator(BlockILU self, Operator op)"""
        return _solvers.BlockILU_SetOperator(self, op)
    SetOperator = _swig_new_instance_method(_solvers.BlockILU_SetOperator)

    def Mult(self, b, x):
        r"""Mult(BlockILU self, Vector b, Vector x)"""
        return _solvers.BlockILU_Mult(self, b, x)
    Mult = _swig_new_instance_method(_solvers.BlockILU_Mult)

    def GetBlockI(self):
        r"""GetBlockI(BlockILU self) -> int *"""
        return _solvers.BlockILU_GetBlockI(self)
    GetBlockI = _swig_new_instance_method(_solvers.BlockILU_GetBlockI)

    def GetBlockJ(self):
        r"""GetBlockJ(BlockILU self) -> int *"""
        return _solvers.BlockILU_GetBlockJ(self)
    GetBlockJ = _swig_new_instance_method(_solvers.BlockILU_GetBlockJ)

    def GetBlockData(self):
        r"""GetBlockData(BlockILU self) -> double *"""
        return _solvers.BlockILU_GetBlockData(self)
    GetBlockData = _swig_new_instance_method(_solvers.BlockILU_GetBlockData)
    __swig_destroy__ = _solvers.delete_BlockILU

# Register BlockILU in _solvers:
_solvers.BlockILU_swigregister(BlockILU)

class ResidualBCMonitor(IterativeSolverMonitor):
    r"""Proxy of C++ mfem::ResidualBCMonitor class."""

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    def __init__(self, ess_dofs_list_):
        r"""__init__(ResidualBCMonitor self, intArray ess_dofs_list_) -> ResidualBCMonitor"""
        _solvers.ResidualBCMonitor_swiginit(self, _solvers.new_ResidualBCMonitor(ess_dofs_list_))

    def MonitorResidual(self, it, norm, r, final):
        r"""MonitorResidual(ResidualBCMonitor self, int it, double norm, Vector r, bool final)"""
        return _solvers.ResidualBCMonitor_MonitorResidual(self, it, norm, r, final)
    MonitorResidual = _swig_new_instance_method(_solvers.ResidualBCMonitor_MonitorResidual)
    __swig_destroy__ = _solvers.delete_ResidualBCMonitor

# Register ResidualBCMonitor in _solvers:
_solvers.ResidualBCMonitor_swigregister(ResidualBCMonitor)

class DirectSubBlockSolver(mfem._par.operators.Solver):
    r"""Proxy of C++ mfem::DirectSubBlockSolver class."""

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    def __init__(self, A, block_dof):
        r"""__init__(DirectSubBlockSolver self, SparseMatrix A, SparseMatrix block_dof) -> DirectSubBlockSolver"""
        _solvers.DirectSubBlockSolver_swiginit(self, _solvers.new_DirectSubBlockSolver(A, block_dof))

    def Mult(self, x, y):
        r"""Mult(DirectSubBlockSolver self, Vector x, Vector y)"""
        return _solvers.DirectSubBlockSolver_Mult(self, x, y)
    Mult = _swig_new_instance_method(_solvers.DirectSubBlockSolver_Mult)

    def SetOperator(self, op):
        r"""SetOperator(DirectSubBlockSolver self, Operator op)"""
        return _solvers.DirectSubBlockSolver_SetOperator(self, op)
    SetOperator = _swig_new_instance_method(_solvers.DirectSubBlockSolver_SetOperator)
    __swig_destroy__ = _solvers.delete_DirectSubBlockSolver

# Register DirectSubBlockSolver in _solvers:
_solvers.DirectSubBlockSolver_swigregister(DirectSubBlockSolver)

class ProductSolver(mfem._par.operators.Solver):
    r"""Proxy of C++ mfem::ProductSolver class."""

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    def __init__(self, A_, S0_, S1_, ownA, ownS0, ownS1):
        r"""__init__(ProductSolver self, Operator A_, Solver S0_, Solver S1_, bool ownA, bool ownS0, bool ownS1) -> ProductSolver"""
        _solvers.ProductSolver_swiginit(self, _solvers.new_ProductSolver(A_, S0_, S1_, ownA, ownS0, ownS1))

    def Mult(self, x, y):
        r"""Mult(ProductSolver self, Vector x, Vector y)"""
        return _solvers.ProductSolver_Mult(self, x, y)
    Mult = _swig_new_instance_method(_solvers.ProductSolver_Mult)

    def MultTranspose(self, x, y):
        r"""MultTranspose(ProductSolver self, Vector x, Vector y)"""
        return _solvers.ProductSolver_MultTranspose(self, x, y)
    MultTranspose = _swig_new_instance_method(_solvers.ProductSolver_MultTranspose)

    def SetOperator(self, op):
        r"""SetOperator(ProductSolver self, Operator op)"""
        return _solvers.ProductSolver_SetOperator(self, op)
    SetOperator = _swig_new_instance_method(_solvers.ProductSolver_SetOperator)
    __swig_destroy__ = _solvers.delete_ProductSolver

# Register ProductSolver in _solvers:
_solvers.ProductSolver_swigregister(ProductSolver)

class AuxSpaceSmoother(mfem._par.operators.Solver):
    r"""Proxy of C++ mfem::AuxSpaceSmoother class."""

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    def __init__(self, op, aux_map, op_is_symmetric=True, own_aux_map=False):
        r"""__init__(AuxSpaceSmoother self, HypreParMatrix const & op, HypreParMatrix * aux_map, bool op_is_symmetric=True, bool own_aux_map=False) -> AuxSpaceSmoother"""
        _solvers.AuxSpaceSmoother_swiginit(self, _solvers.new_AuxSpaceSmoother(op, aux_map, op_is_symmetric, own_aux_map))

    def Mult(self, x, y):
        r"""Mult(AuxSpaceSmoother self, Vector x, Vector y)"""
        return _solvers.AuxSpaceSmoother_Mult(self, x, y)
    Mult = _swig_new_instance_method(_solvers.AuxSpaceSmoother_Mult)

    def MultTranspose(self, x, y):
        r"""MultTranspose(AuxSpaceSmoother self, Vector x, Vector y)"""
        return _solvers.AuxSpaceSmoother_MultTranspose(self, x, y)
    MultTranspose = _swig_new_instance_method(_solvers.AuxSpaceSmoother_MultTranspose)

    def SetOperator(self, op):
        r"""SetOperator(AuxSpaceSmoother self, Operator op)"""
        return _solvers.AuxSpaceSmoother_SetOperator(self, op)
    SetOperator = _swig_new_instance_method(_solvers.AuxSpaceSmoother_SetOperator)

    def GetSmoother(self):
        r"""GetSmoother(AuxSpaceSmoother self) -> HypreSmoother &"""
        return _solvers.AuxSpaceSmoother_GetSmoother(self)
    GetSmoother = _swig_new_instance_method(_solvers.AuxSpaceSmoother_GetSmoother)
    __swig_destroy__ = _solvers.delete_AuxSpaceSmoother

# Register AuxSpaceSmoother in _solvers:
_solvers.AuxSpaceSmoother_swigregister(AuxSpaceSmoother)



